{"meta":{"title":"JUN","subtitle":"JUN","description":"西北工业大学 | 计算机科学与技术 | C/C++开发","author":"lxjj","url":"https://lilixj.github.io","root":"/"},"pages":[{"title":"404","date":"2021-07-10T16:32:54.000Z","updated":"2021-07-10T16:34:51.148Z","comments":true,"path":"404/index.html","permalink":"https://lilixj.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-07-10T16:32:19.000Z","updated":"2021-07-10T16:33:37.257Z","comments":true,"path":"about/index.html","permalink":"https://lilixj.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-10T16:27:00.000Z","updated":"2021-07-10T16:28:51.506Z","comments":true,"path":"categories/index.html","permalink":"https://lilixj.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://lilixj.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-07-10T16:32:28.000Z","updated":"2022-01-16T03:49:48.025Z","comments":true,"path":"contact/index.html","permalink":"https://lilixj.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 xxxxx友链信息 博客名称: xxxxx 博客网址: xxxxx 博客头像: xxxxx 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2021-07-10T16:32:40.000Z","updated":"2022-01-16T14:49:01.985Z","comments":true,"path":"friends/index.html","permalink":"https://lilixj.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-07-10T16:32:00.000Z","updated":"2021-07-10T16:35:44.581Z","comments":true,"path":"tags/index.html","permalink":"https://lilixj.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode_record","slug":"leetcode-record","date":"2022-01-21T15:52:44.000Z","updated":"2022-01-22T09:39:55.762Z","comments":true,"path":"posts/63c3abbd.html","link":"","permalink":"https://lilixj.github.io/posts/63c3abbd.html","excerpt":"","text":"2021-1-21：二进制手表（有趣的一题） 题目：二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。 小时不会以零开头： 例如，”01:00” 是无效的时间，正确的写法应该是 “1:00” 。分钟必须由两位数组成，可能会以零开头： 例如，”10:2” 是无效的时间，正确的写法应该是 “10:02” 。 示例 1： 输入：turnedOn &#x3D; 1 输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;] 示例 2： 输入：turnedOn &#x3D; 9 输出：[] 提示： 0 &lt;&#x3D; turnedOn &lt;&#x3D; 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-watch著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 删除回文子序列给你一个字符串 s，它仅由字母 ‘a’ 和 ‘b’ 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-palindromic-subsequences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 &#96;&#96;&#96; #### **最长回文串** 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。 注意: 假设字符串的长度不会超过 1010。 来源：力扣（LeetCode） 链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-palindrome 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 &#96;&#96;&#96;&#96; ### 解题思路 **哈希集合** 1. 某个字符出现两次，可加入回文字符串； 2. 用过的字符需要删除，遇到新的重新添加到哈希表中； 3. 遍历完原字符串后，检查哈希集合是否为空（是否有字符是奇数个，被剩下了），如不是，则加上一个字符长度，否则不处理 ### 代码 &#96;&#96;&#96;cpp class Solution &#123; public: int longestPalindrome(string s) &#123; int cnt &#x3D; 0; set&lt;char&gt; ss; for(int i&#x3D;0;i&lt;s.length();i++) &#123; if(ss.count(s[i])!&#x3D;0) &#123; ss.erase(s[i]); cnt+&#x3D;2; &#125; else &#123; ss.insert(s[i]); &#125; &#125; return ss.empty()?cnt:cnt+1; &#125; &#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lilixj.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://lilixj.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"hexo-FAQ","slug":"hexo-FAQ","date":"2022-01-16T07:40:39.000Z","updated":"2022-01-16T14:21:23.836Z","comments":true,"path":"posts/90f0f1a2.html","link":"","permalink":"https://lilixj.github.io/posts/90f0f1a2.html","excerpt":"","text":"HEXO配置过程中遇到的问题hexo代码块显示异常使用matery主题后，代码块的行号和内容分开，如下图： 使用Drun1baby推荐的方法： 对博客根目录的_config.yml的对应位置，进行如图所示配置后，问题并未解决。 后又通过github找到一个主题为“代码高亮失效”的issue提到： 我发现了，这样写就正常了，和prism的版本也有关系，我用的是从官网定制的 &#96;&#96;&#96;lang-javascript code \\&#96;&#96;&#96; 要加个前缀 lang- 于是，我在出错文件的代码块也加上了前缀，重新编译并发布后，问题解决！后又将lang-删掉，再次编译，也不再出现之前的问题。神奇！ 中文乱码 网页名字乱码 原因：站点配置文件没有使用utf-8编码而导致的中文乱码。 解决办法：将站点配置文件另存为utf-8格式。 博客内容乱码： 原因：markdown文件不是utf-8编码 解决办法：markdown文件另存为utf-8格式。 点击文章后总是跳转到undefined.html原因：没有该文章对应的html文件 解决办法： 安装hexo-abbrlink插件 npm install hexo-abbrlink --save 清除缓存并编译 hexo clean &amp;&amp; hexo g 引用本地图片不显示原因：abbrlink和hexo-asset-image插件冲突 解决办法：foreveryang321修改的hexo-asset-image库 注：但是在实际过程中发现图片的路径多了一级目录，通过在源代码中进行关键词搜索，发现是_config.yml中的url多设置了一级。 修改后，问题解决，图片正常显示！ hexo server “Cannot GET /“ 在Hexo博客中，出现Cannot GET/xxx错误便意味着xxx文件未被找到。Cannot GET/xxx错误本质是hexo server返回的一个404错误。开始查找原因 网上说是由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs --save npm install hexo-renderer-stylus --save npm install hexo-renderer-marked--save 三条命令执行完这时候重新启动本地服务再访问 问题解决，可以正常访问！ 如何使用GitPages部署网站由于某些原因，现在github的主分支名不再以master命令，为简单起见，在hexo根目录的_config.yml文件中： deploy: type: git repository: git@github.com:你的用户名&#x2F;你的用户名.github.io.git branch: main 将远程分支直接设为main。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/tags/hexo/"}]},{"title":"flash-linux0.11-talk笔记","slug":"OperatingSystem","date":"2022-01-16T03:27:43.956Z","updated":"2022-01-21T05:29:48.791Z","comments":true,"path":"posts/d93cc07a.html","link":"","permalink":"https://lilixj.github.io/posts/d93cc07a.html","excerpt":"","text":"Bootsec .s关键点原文链接：https://github.com/sunym1993/flash-linux0.11-talk 第一回 最开始的两行代码当你按下开机键的那一刻，在主板上提前写死的固件程序 BIOS 会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00 这个位置，并跳转到那个位置进行执行。 启动区：硬盘中的0盘0道1扇区的512个字节的最后两个字节分别是0x55和0xaa。 mov ax,0x07c0 mov ds,ax 第二回 给自己挪个地儿:mov ax,0x07c0 :mov ds,ax mov ax,0x9000 mov es,ax mov cx,#256 sub si,si sub di,di rep movw movw 表示复制一个字（word 16位），那其实就是不断重复地复制一个字。 那下面自然就有三连问： 重复执行多少次呢？是 cx 寄存器中的值，也就是 256 次。 从哪复制到哪呢？是从 ds:si 处复制到 es:di 处。 一次复制多少呢？刚刚说过了，复制一个字，16 位，也就是两个字节。 “将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到 0x90000 处。” jmpi go,0x9000 go: mov ax,cs mov ds,ax jmpi 是一个段间跳转指令，表示跳转到 0x9000:go 处执行。 第三回 做好最最基础的准备工作go: mov ax,cs mov ds,ax mov es,ax mov ss,ax mov sp,#0xFF00 都做了些啥事呢？ 第一，代码从硬盘移到内存，又从内存挪了个地方，放在了 0x90000 处。 第二，数据段寄存器 ds 和代码段寄存器 cs 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可了。 第三，栈顶地址被设置为了 0x9FF00，具体表现为栈段寄存器 ss 为 0x9000，栈基址寄存器 sp 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置 0x90000，所以栈向下发展就很难撞见代码所在的位置，也就比较安全。这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。 其实就是分别设置代码段寄存器 cs，数据段寄存器 ds，栈段寄存器 ss 和栈基址寄存器 sp 的值。 其实操作系统在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下内存的初步规划。其中访问代码和访问数据的规划方式就是设置了一个基址而已，访问栈就是把栈顶指针指向了一个远离代码位置的地方而已。 第四回 把自己在硬盘里的其他部分也放到内存来 “简单说，就是设置了如何访问数据的数据段，如何访问代码的代码段，以及如何访问栈的栈顶指针，也即初步做了一次内存规划，从 CPU 的角度看，访问内存，就这么三块地方而已。” 接下来： load_setup: mov dx,#0x0000 ; drive 0, head 0 mov cx,#0x0002 ; sector 2, track 0 mov bx,#0x0200 ; address &#x3D; 512, in 0x9000 mov ax,#0x0200+4 ; service 2, nr of sectors int 0x13 ; read it, start interrupt of number 0x13 jnc ok_load_setup ; ok - continue mov dx,#0x0000 mov ax,#0x0000 ; reset the diskette int 0x13 jmp load_setup ok_load_setup: ... 作用：就是将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区。 ok_load_setup: ... mov ax,#0x1000 mov es,ax ; segment of 0x10000 call read_it ... jmpi 0,0x9020 作用：把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处。 整个操作系统的编译过程说下。整个编译过程，就是通过 Makefile 和 build.c 配合完成的，最终会： 1. 把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。 2. 把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。 3. 把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。 setup.s第五回 进入保护模式前的最后一次折腾内存start: mov ax,#0x9000 ; this is done in bootsect already, but... mov ds,ax mov ah,#0x03 ; read cursor pos xor bh,bh int 0x10 ; save it in known place, con_init fetches mov [0],dx ; it from 0x90000. 这里说明一下：计算机在加电自检后会自动初始化到文字模式，在这种模式下，一屏幕可以显示 25 行，每行 80 个字符，也就是 80 列。 那下一步 mov [0],dx 就是把这个光标位置存储在 [0] 这个内存地址处。注意，前面我们说过，这个内存地址仅仅是偏移地址，还需要加上 ds 这个寄存器里存储的段基址，最终的内存地址是在 0x90000 处，这里存放着光标的位置，以便之后在初始化控制台的时候用到。 所以从这里也可以看出，这和我们平时调用一个方法没什么区别，只不过这里的寄存器的用法相当于入参和返回值，这里的 0x10 中断号相当于方法名。 内存地址 长度(字节) 名称 0x90000 2 光标位置 0x90002 2 扩展内存数 0x90004 2 显示页面 0x90006 1 显示模式 0x90007 1 字符列数 0x90008 2 未知 0x9000A 1 显示内存 0x9000B 1 显示状态 0x9000C 2 显卡特性参数 0x9000E 1 屏幕行数 0x9000F 1 屏幕列数 0x90080 16 硬盘1参数表 0x90090 16 硬盘2参数表 0x901FC 2 根设备号 cli ; no interrupts allowed ; ; first we move the system to it&#39;s rightful place mov ax,#0x0000 cld ; &#39;direction&#39;&#x3D;0, movs moves forward do_move: mov es,ax ; destination segment add ax,#0x1000 cmp ax,#0x9000 jz end_move mov ds,ax ; source segment sub di,di sub si,si mov cx,#0x8000 rep movsw jmp do_move ; then we load the segment descriptors end_move: ... 由于之前的各种加载和复制，导致内存看起来很乱，是时候进行一波取舍和整理了，我们重新梳理一下此时的内存布局。 栈顶地址仍然是 0x9FF00 没有改变。 0x90000 开始往上的位置，原来是 bootsect 和 setup 程序的代码，现 bootsect 的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些临时存放的数据给覆盖了一部分。 内存最开始的 0 到 0x80000 这 512K 被 system 模块给占用了，之前讲过，这个 system 模块就是除了 bootsect 和 setup 之外的全部程序链接在一起的结果，可以理解为操作系统的全部。 [1]:","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://lilixj.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"操作系统/linux","permalink":"https://lilixj.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://lilixj.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"linux","permalink":"https://lilixj.github.io/tags/linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-01-16T02:35:00.484Z","updated":"2022-01-21T15:54:02.416Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://lilixj.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/tags/hexo/"}]}],"categories":[{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/categories/hexo/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lilixj.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"操作系统/linux","permalink":"https://lilixj.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://lilixj.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"https://lilixj.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"hexo","slug":"hexo","permalink":"https://lilixj.github.io/tags/hexo/"},{"name":"操作系统","slug":"操作系统","permalink":"https://lilixj.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux","slug":"linux","permalink":"https://lilixj.github.io/tags/linux/"}]}